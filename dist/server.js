"use strict";
/**
 * ## Simple server for EPUB generation
 *
 * It takes the parameters in a query string, generates and returns an EPUB 3.2 instance to the caller.
 *
 * The possible query parameters are
 *
 * ```
 * url              The URL for the content
 * respec           Whether the source is in respec (true) or a final HTML (false).
 * publishDate      Publication date
 * specStatus       Specification type
 * addSectionLinks  Add section links with "ยง"
 * maxTocLevel      Max TOC level
 *```
 *
 *
 * The module is a wrapper around a standard node.js `http.CreateServer`, and a call to [[create_epub]].
 *
 * ### Usage examples:
 *
 * (In all examples, the URL for the server is set to `https://epub.example.org`)
 *
 * Convert the HTML file (as generated by ReSpec) to an EPUB 3.2 file. The generated publication's name is `short-name.epub`, where `short-name` is set in the ReSpec configuration:
 *
 * ``` sh
 * https://epub.example.org?url=https://www.example.org/doc.html
 * ```
 *
 * Convert the HTML _ReSpec source_ to an EPUB 3.2 file. The source is converted on-the-fly by respec:
 *
 * ``` sh
 * https://epub.example.org?url=https://www.example.org/doc.html&respec=true`
 * ```
 *
 * Convert the HTML _ReSpec source_ to an EPUB 3.2 file, setting its spec status to REC. The source is converted on-the-fly by respec, overwriting the `specStatus` entry in the configuration to `REC`:
 *
 * ``` sh
 * https://epub.example.org?url=https://www.example.org/doc.html&respec=true&specStatus=REC`
 * ```

 * @packageDocumentation
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
*
*
*/
const http_1 = __importDefault(require("http"));
const urlHandler = __importStar(require("url"));
const _ = __importStar(require("underscore"));
const r2epub = __importStar(require("./index"));
const constants = __importStar(require("./lib/constants"));
const home = __importStar(require("./lib/home"));
/**
 * Generate the EPUB file. This is a wrapper around [[create_epub]], creating the necessary arguments [[Options]] structure based on the incoming URL's query string.
 *
 * @async
 * @param query - The query string from the client
 */
async function get_epub(query) {
    const respec_args = _.omit(query, 'respec', 'url', 'submit');
    _.keys(respec_args).forEach((key) => {
        if (respec_args[key] !== undefined && (respec_args[key] === '' || respec_args[key] === 'null')) {
            delete respec_args[key];
        }
    });
    const url = query.url;
    const options = {
        respec: (query.respec !== undefined && (query.respec === 'true' || query.respec === true)),
        config: respec_args,
    };
    const the_ocf = await r2epub.convert(url, options);
    const content = await the_ocf.get_content();
    const now = (new Date()).toString();
    return {
        content: content,
        headers: {
            'Content-type': constants.media_types.epub,
            'Expires': now,
            'Last-Modified': now,
            'Content-Length': content.length,
            'Accept-Ranges': 'none',
            'Content-Language': 'en-US',
            'Content-Disposition': `attachment; filename=${the_ocf.name}`
        }
    };
}
/**
 * Run a rudimentary Web server calling out to [[convert]] via [[get_epub]] to return an EPUB 3.2 instance when invoked.
 * If there is no proper query string a fixed page is displayed.
 *
 * @async
 */
async function serve() {
    const port = process.env.PORT || process.env.R2EPUB_PORT || constants.local_port_number;
    console.log(`r2epub server starting on port ${port}`);
    http_1.default.createServer(async (request, response) => {
        const error = (code, e) => {
            const error_headers = {
                'Content-type': constants.media_types.text,
                'Content-Language': 'en-US'
            };
            response.writeHead(code, _.extend(error_headers, constants.CORS_headers));
            response.write(e);
        };
        try {
            if (request.method === 'GET' || request.method === 'HEAD') {
                const query = urlHandler.parse(request.url, true).query;
                const host = `http://${request.headers.host}`;
                if (query === null || query.url === undefined) {
                    // fall back on the fixed home page
                    response.writeHead(200, _.extend({ 'Content-type': 'text/html' }, constants.CORS_headers));
                    response.write(home.homepage.replace(/%%%SERVER%%%/g, host));
                }
                else {
                    const the_book = await get_epub(query);
                    response.writeHead(200, _.extend(the_book.headers, constants.CORS_headers));
                    response.write(the_book.content);
                }
            }
            else {
                error(501, `Invalid HTTP request method: ${request.method}`);
            }
        }
        catch (e) {
            error(400, `EPUB Generation error: ${e.toString()}`);
        }
        finally {
            response.end();
        }
    }).listen(port);
}
serve();
//# sourceMappingURL=server.js.map