/**
 * ## Simple server for EPUB generation
 *
 * It takes the parameters in a query string, generates and returns an EPUB 3.4 instance to the caller.
 *
 * The possible query parameters are
 *
 * ```txt
 * url              The URL for the content
 * respec           Whether the source is in respec (true) or a final HTML (false).
 * publishDate      Publication date
 * specStatus       Specification type
 * addSectionLinks  Add section links with "ยง"
 * maxTocLevel      Max TOC level
 *```
 *
 *
 * The module is a wrapper around a standard node.js `http.CreateServer` (emulated in `deno`), and a call to the [convert](../lib/convert.ts/index.html) function.
 *
 * ### Usage examples:
 *
 * (In all examples, the URL for the server is set to `https://epub.example.org`)
 *
 * Convert the HTML file (as generated by ReSpec) to an EPUB 3.4 file. The generated publication's name is `short-name.epub`, where `short-name` is set in the ReSpec configuration:
 *
 * ``` sh
 * https://epub.example.org?url=https://www.example.org/doc.html
 * ```
 *
 * Convert the HTML _ReSpec source_ to an EPUB 3.4 file. The source is converted on-the-fly by respec:
 *
 * ``` sh
 * https://epub.example.org?url=https://www.example.org/doc.html&respec=true
 * ```
 *
 * Convert the HTML _ReSpec source_ to an EPUB 3.4 file, setting its spec status to REC. The source is converted on-the-fly by respec, overwriting the `specStatus` entry in its configuration to `REC`:
 *
 * ``` sh
 * https://epub.example.org?url=https://www.example.org/doc.html&respec=true&specStatus=REC
 * ```
 *
 * Generates a collection, described by the configuration file. (See the [separate module](../lib/clib/args.ts/) for more details on the configuration file.)
 *
 * ```sh
 *  https://epub.example.org?url=https://www.example.org/collection.json
 * ```
 *
 * @packageDocumentation
 * @module
 */

/**
 *
 *
 */


import * as http       from 'node:http';
import * as urlHandler from 'node:url';
import * as r2epub     from './index.ts';
import * as common     from './lib/common.ts';
import type * as ocf   from './lib/ocf.ts';
import * as home       from './lib/home.ts';
import * as process    from 'node:process';
import { Buffer }      from 'node:buffer';


/**
 * Return type of [[get_epub]] (to be handled by the server);
 */
interface Content {
    /**
     * The real epub content: a Buffer as generated through the [[OCF]] class.
     */
    content: Buffer;
    /**
     * Additional HTTP Response headers, to accompany the full response. (File name, dates, etc.).
     */
    // eslint-disable-next-line @typescript-eslint/ban-types
    headers :object;
}

/**
 * @hidden
 */
interface Query {
    [index :string] :string | string[] | boolean
}

type Args = Omit<Query, "respec" | "url" | "submit">;

/**
 * Generate the EPUB file. This is a wrapper around [[create_epub]], creating the necessary arguments [[Options]] structure based on the incoming URL's query string.
 *
 * @async
 * @param query - The query string from the client
 */
async function get_epub(query :Query) : Promise<Content> {
    const respec_args :Args = ((): Args => {
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        // deno-lint-ignore no-unused-vars
        const { respec, url, submit, ...args } = query as Args;
        for (const key of Object.keys(args)) {
            if (args[key] !== undefined && (args[key] === '' || args[key] === 'null')) {
                delete args[key];
            }
        }
        return args;
    })()

    const url :string = query.url as string;
    const options :r2epub.Options = {
        respec : (query.respec !== undefined && (query.respec === 'true' || query.respec === true)),
        config : respec_args,
    }

    const the_ocf :ocf.OCF     = await r2epub.convert(url, options)
    const content :ArrayBuffer = await the_ocf.get_content() as ArrayBuffer;
    const finalContent :Buffer = Buffer.from(content);
    const now :string          = (new Date()).toString();

    return {
        content : finalContent,
        headers : {
            'Content-type'        : common.media_types.epub,
            'Expires'             : now,
            'Last-Modified'       : now,
            'Content-Length'      : finalContent.length,
            'Accept-Ranges'       : 'none',
            'Content-Language'    : 'en-US',
            'Content-Disposition' : `attachment; filename=${the_ocf.name}`,
        },
    }
}


/**
 * Run a rudimentary Web server calling out to [[convert]] via [[get_epub]] to return an EPUB 3.4 instance when invoked.
 * If there is no proper query string a fixed page is displayed.
 *
 * This function is automatically started when this module is used from a command line.
 *
 * @async
 */
async function serve(): Promise<void> {
    const port :string = process.env.PORT || process.env.R2EPUB_PORT || common.local_port_number;
    console.log(`r2epub service: server starting on port ${port} (${(new Date().toISOString())})`);
    http.createServer(async (request :http.IncomingMessage, response :http.ServerResponse) => {
        const error = (code :number, e :string) => {
            const error_headers = {
                'Content-type'     : common.media_types.text,
                'Content-Language' : 'en-US',
            };
            response.writeHead(code, {
                ...common.CORS_headers,
                ...error_headers,
            });
            response.write(e);
        }
        try {
            if (request.method === 'GET' || request.method === 'HEAD') {
                if (request.url === undefined) {
                    error(400, 'EPUB Generation error: no URL provided');
                    return;
                }
                const query  = urlHandler.parse(request.url, true).query;
                // On labs.w3.org this will produce a localhost:8000, which is incorrect.
                // I am not sure how to find out, on labs, that is really using w3c's lab, and,
                // for the time being, w3c lab is the only deployment, so I hardcode the host. To
                // find out later...
                // const host = `http://${request.headers.host}`; 
                const host = "https://labs.w3.org/r2epub/";

                if (query === null || query.url === undefined) {
                    // fall back on the fixed home page
                    response.writeHead(200, {
                        ...common.CORS_headers,
                        ...{ 'Content-type': 'text/html' },
                    });
                    response.write(home.homepage.replace(/%%%SERVER%%%/g, host));
                } else {
                    console.log(`r2epub service: converting ${query.url} (${(new Date().toISOString())})`)
                    const the_book :Content = await get_epub(query as Query);
                    response.writeHead(200, {
                        ...common.CORS_headers,
                        ...the_book.headers,
                    });
                    response.write(the_book.content);
                }
            } else {
                error(501, `Invalid HTTP request method: ${request.method}`);
            }
        } catch (e) {
            const errorMessage = (e instanceof Error) ? e.toString() : String(e);
            error(400, `EPUB Generation error: ${errorMessage}`);
        } finally {
            response.end();
        }
    }).listen(port);
}

serve();



